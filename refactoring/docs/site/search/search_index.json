{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This resource describes the functionality of the quantum genome encoding library that has been developed as part of Phase I of the Wellcome Leap Quantum Pangenomics project, developed by a team spanning the University of Melbourne, the University of Cambridge, Kyiv Academic University, and the Wellcome Trust Sanger Institute.</p> <p>The library presents a novel and performant method of encoding genomic data for use in quantum computing and quantum computing simulations on high performance computing (HPC) clusters.</p>"},{"location":"#the-algorithm","title":"The Algorithm","text":"<p>In broad strokes, the method obtains a quantum circuit encoding of genomic data by producing a normalised state vector from the data. This state vector is then transformed into a tensor of high rank, which is decomposed into a Matrix Product State (MPS) by repeated applications of the Singular Value Decomposition (SVD). This matrix product state is then used to construct a quantum circuit by repeatedly applying unitary gates until the desired fidelity ot the input state is achieved.</p>"},{"location":"#state-vector-encoding","title":"State vector encoding","text":"<p>To encode the genomic data as a normalised quantum state vector, we use a binary position and base register to obtain a compact description.</p> <p>The base register requires two qubits, and we map the bases according to the following table:</p> A T G C 00 01 10 11 <p>We then combine this with the binary representation of the index along the genome read to produce a new index for the state vector - the value of the state vector component at the new index will be set to <code>1</code> and all others will be set to <code>0</code>. Finally, the state vector will be normalised to unit magnitude.</p> <p>Example</p> <p>The (very) short genome read \\(AT\\) can be encoded in 3 qubits, and becomes \\(\\frac{1}{\\sqrt{2}}(1, 0, 0, 0, 0, 1, 0, 0)\\).</p> <p>In general, this means that a genome of length \\(L\\) requires \\(N = \\lceil \\log_2{L} \\rceil + 2\\) qubits to be encoded in our framework.</p> <p>The number of qubits required becomes the number of nodes in the MPS.</p> <p>The encoding is implemented in <code>encoding.encode_genome</code>, there is also a companion function to decode the state vector into a genome, <code>encoding.decode_state</code>.</p>"},{"location":"#construction-of-mps","title":"Construction of MPS","text":"<p>We construct the MPS representation of a state vector by first recasting it as a high rank tensor (i.e. a tensor of rank \\(2^{N-1}\\) where \\(N\\) is the number of qubits required). No information is lost in this stage as this is a simple 'reshape' of the vector. Each rank has physical dimension \\(d=2\\).</p> <p>The next stage is to decompose the tensor into the MPS form, with a given bond dimension \\(D\\) (we detail how to calculate this parameter in the next section). This is done by performing a SVD between each rank (i.e. \\(2^{N-1}-1\\) SVD operations), as illustrated in the figure below (tensornetwork.org):</p> <p> </p> <p>The SVD are performed between each rank in sequence to obtain the MPS encoding. Importantly, information is lost (in general) in this stage, as we have reduced the amount of data - this means the fidelity of the representation to the original state vector is reduced. Strictly, the equality in the figure does not hold. We can summarise the high-level process in the following flow chart:</p> <pre><code>graph LR\n  A[Genome read] --&gt; B[State vector];\n  B --&gt;|Reshape| C[High rank tensor];\n  C --&gt;D{Done all SVD required ?};\n  D --&gt;|Yes| E[Finished, return MPS];\n  D --&gt;|No| F[Perform SVD between next two ranks];\n  F --&gt;D;</code></pre> <p>This is implemented in <code>encoding.create_mps</code>, and can create a MPS from an arbitrary normalised state vector.</p>"},{"location":"#fidelity-and-the-required-bond-dimension","title":"Fidelity and the required bond dimension","text":"<p>A method is provided in the code to estimate the required bond dimension, <code>encoding.analyse_required_bond_dim</code>. For a given state vector, this method returns an estimate of the minimum bond dimension required to achieve a specified fidelity to the input state vector.</p> <p>In general, a larger bond dimension will give a larger fidelity to the original state since more of the original data would be retained. However, the computational cost of working with the MPS increases as the bond dimension increases for precisely the same reason.</p> <p>This method will analyse the fidelity of the MPS to the original state vector for a given bond dimension and incrememnt the bond dimension until the fidelity required is achieved.</p> <p> </p> <p>Importantly, we do not increment the bond dimension by unity after each check - we save on computational cost by using a similar method to gradient descent and estimate the jump in bond dimension required. See the figure above for an example of the reconstruction error as plotted against the bond dimension for a read of length 100.</p> <p>The descent model is tuneable so that the risk of significantly overestimating the required bond dimension may be mitigated.</p>"},{"location":"#converting-mps-to-quantum-circuits","title":"Converting MPS to Quantum Circuits","text":"<p>The correspondence between quantum circuits and MPS is well-understood and documented, in short a quantum circuit with no gates is the tensor product of the input qubits. Applying gates is then equivalent to contracting two of the qubits together. For a two qubit gate, the input qubits are entangled to a tensor of rank two which can be decomposed with the SVD. Applying this for all the gates in a generic quantum circuit gives us a MPS state. This is illustrated in the figure below (Guala et al., 2023):</p> <p> </p> <p>In the library, we use the method <code>encoding.convert_mps_to_circuit</code> to produce a quantum circuit that is equivalent to a matrix product state. The main input to the method is the state vector which the quantum circuit should reproduce to a requested fidelity. The quantum circuits are implemented using the IBM QisKit API, though we plan to remove QisKit dependence from the library in the future.</p> <p>The process is iterative, and adds unitary gates to the quantum circuit until the required acuracy has been achieved. The accuracy is judged at each stage by producing the inverse of the circuit and comparing to the original state vector.</p> <p>The key innovation of this method is the method of producing the two-qubit unitary gates, which uses the MPS formulation of the circuit inverse. The gates are produced by reorganising the tensor corresponding to each node in the MPS into a matrix, and concatenating each matrix with its null state. The high-level operation of the algorithm is shown in the flow chart below:</p> <pre><code>graph LR\n  A[State vector] --&gt; B[Initialise empty circuit];\n  B --&gt;C[Produce MPS];\n  C --&gt;D[Produce gates from MPS];\n  D --&gt;E[Add gates to circuit];\n  E --&gt;F{Circuit inverse == state vector ?};\n  F --&gt;|Yes| G[Finished, return circuit];\n  F --&gt;|No| H[Create state vector from inverse];\n  H --&gt;B;</code></pre> <p>It is worth focusing on the method of producing gates, this is done by iterating in reverse through the MPS nodes and applying the procedure specified above. This means reshaping each node \\(n_i\\) in the tensor network first to \\(4\\times x_i\\) matrices \\(V_i\\) (where \\(x_i\\) is computed dynamically for dimensional consistency). The null space of the matrix \\(V_i\\) is also computed, which we name \\(\\operatorname{null}(A_i)\\).</p> <p>These matrices are concatenated to form a unitary gate \\(U_i=V_i \\frown \\operatorname{null}(A_i)\\), which entangles qubits \\(N-i-1\\) and \\(N-i\\) with \\(N\\) the total number of qubits.</p> <p>This method of iteratively adding unitary gates produces circuits more economical in depth compared to the pure QisKit implementation (using only basic Clifford gates), as illustrated by the gate count comparisons below:</p> <p> </p> <p>The greater economy in gates is illustrated clearly, the discrete jumps in gate count indicate an increase in the number of qubits required to encode the genome.</p> <p>Even without optimisation, the economy of this approach makes clear that MPS can provide a more favourable encoding than pure QisKit. We relegate the discussion of the optimisation to future documentation for now.</p>"},{"location":"encoding_ref/","title":"API Reference - Encoding","text":"<p>The <code>encoding</code> methods (<code>quantum_genome_encoder.encoding.py</code>) are documented in this section.</p>"},{"location":"encoding_ref/#genome-generation-encoding-and-decoding","title":"Genome generation, encoding and decoding","text":"<p>The genome and state-specific encoding/decoding functionality is documented in this section.</p> <p><pre><code>quantum_genome_encoder.generate_genome(length)\n</code></pre> </p> <p>Generates a genome of length <code>length</code>, using the nucleobase set of {A, T, G, C}.</p> <p><pre><code>quantum_genome_encoder.read_genome(file, length)\n</code></pre> </p> <p>Reads length of a genome from given file.</p> <p><pre><code>quantum_genome_encoder.encode_genome(genome)\n</code></pre> </p> <p>Encodes the given genome into a binary representation with <code>BASE_MAP</code></p> <p><pre><code>quantum_genome_encoder.decode_state(statevector, num_qubits, tol)\n</code></pre> </p> <p>Decodes state vector into a genome, the tolerance parameter is heuristic and can be refined.</p>"},{"location":"encoding_ref/#quantum_genome_encoder.generate_genome--parameters","title":"Parameters:","text":"<p><code>length</code> : <code>int</code> -      Length of required genome.</p>"},{"location":"encoding_ref/#quantum_genome_encoder.generate_genome--returns","title":"Returns:","text":"<p><code>genome</code> : <code>np.ndarray</code> -      An array of nucleobases forming the genome.</p> Source code in <code>quantum_genome_encoder/encoding.py</code> <pre><code>def generate_genome(length):\n    \"\"\"\n    Generates a genome of length `length`, using the nucleobase set of\n    {A, T, G, C}.\n\n    Parameters:\n    -----------\n    `length` : `int` - \n        Length of required genome.\n\n    Returns:\n    --------\n    `genome` : `np.ndarray` - \n        An array of nucleobases forming the genome.\n    \"\"\"\n\n    alphabet = [\"A\", \"T\", \"G\", \"C\"]\n\n    genome = np.random.choice(alphabet, length)\n\n    return genome\n</code></pre>"},{"location":"encoding_ref/#quantum_genome_encoder.read_genome--parameters","title":"Parameters:","text":"<p><code>file</code> : <code>str</code> -      Location of data file where genome is stored.</p> <p><code>length</code> : <code>int</code> -      Length of genome to be read.</p>"},{"location":"encoding_ref/#quantum_genome_encoder.read_genome--returns","title":"Returns:","text":"<p><code>genome</code> : <code>np.ndarray</code> -      An array of nucleobases forming the genome</p> Source code in <code>quantum_genome_encoder/encoding.py</code> <pre><code>def read_genome(file, length):\n    \"\"\"\n    Reads length of a genome from given file.\n\n    Parameters:\n    ----------\n    `file` : `str` - \n        Location of data file where genome is stored.\n\n    `length` : `int` - \n        Length of genome to be read.\n\n    Returns:\n    --------\n    `genome` : `np.ndarray` - \n        An array of nucleobases forming the genome\n    \"\"\"\n\n    with open(file, \"r\") as filehandler:\n        genome = filehandler.read().replace(\"\\n\", \"\")\n\n    genome = [\n        re.sub(r\"[^ATGC]\", \"\", genome)[i % len(genome)]\n        for i in range(length, length + length)\n    ]\n\n    return genome\n</code></pre>"},{"location":"encoding_ref/#quantum_genome_encoder.encode_genome--parameters","title":"Parameters:","text":"<p><code>genome</code> : <code>np.ndarray</code> -      Genome array comprised of nucleobases from {A, T, G, C}.</p>"},{"location":"encoding_ref/#quantum_genome_encoder.encode_genome--returns","title":"Returns:","text":"<p><code>encoded_genome</code> : <code>np.ndarray</code> -      Normalised binary encoding of the given genome.</p> <p><code>num_qubits</code> : <code>int</code> -      Total number of qubits required for encoding.</p> Source code in <code>quantum_genome_encoder/encoding.py</code> <pre><code>def encode_genome(genome):\n    \"\"\"\n    Encodes the given genome into a binary representation with\n    `BASE_MAP`\n\n    Parameters:\n    ----------\n    `genome` : `np.ndarray` - \n        Genome array comprised of nucleobases from {A, T, G, C}.\n\n    Returns:\n    -------\n    `encoded_genome` : `np.ndarray` - \n        Normalised binary encoding of the given genome.\n\n    `num_qubits` : `int` - \n        Total number of qubits required for encoding.\n    \"\"\"\n\n    pos_qubits = int(np.ceil(np.log2(len(genome))))\n    data_qubits = 2\n\n    num_qubits = pos_qubits + data_qubits\n\n    encoded_genome = np.zeros(int(2**num_qubits), dtype=np.complex128)\n\n    for idx, base in enumerate(genome):\n        idx_mod = int(bin(idx)[2:].zfill(pos_qubits) + BASE_MAP[base], 2)\n        encoded_genome[idx_mod] = 1.0\n\n    return encoded_genome / np.sqrt(np.sum(encoded_genome)), num_qubits\n</code></pre>"},{"location":"encoding_ref/#quantum_genome_encoder.decode_state--parameters","title":"Parameters:","text":"<p><code>statevector</code> : <code>np.typing.ArrayLike</code> -      Normalised quantum state vector to decode.</p> <p><code>num_qubits</code> : <code>int</code> -      Total number of qubits used in the encoding.</p> <p><code>tol</code> : <code>float</code> -     Tolerance of decoding, by default set to TOL_DEFAULT_ERR</p>"},{"location":"encoding_ref/#quantum_genome_encoder.decode_state--returns","title":"Returns:","text":"<p><code>decoded</code> : <code>str</code> -      Genome as reconstructed from inverse of encode_genome</p> Source code in <code>quantum_genome_encoder/encoding.py</code> <pre><code>def decode_state(statevector, num_qubits, tol=TOL_DEFAULT_ERR):\n    \"\"\"\n    Decodes state vector into a genome, the tolerance parameter is heuristic\n    and can be refined.\n\n    Parameters:\n    -----------\n    `statevector` : `np.typing.ArrayLike` - \n        Normalised quantum state vector to decode.\n\n    `num_qubits` : `int` - \n        Total number of qubits used in the encoding.\n\n    `tol` : `float` -\n        Tolerance of decoding, by default set to TOL_DEFAULT_ERR\n\n    Returns:\n    --------\n    `decoded` : `str` - \n        Genome as reconstructed from inverse of encode_genome\n    \"\"\"\n    decoded = \"\"\n\n    for idx, element in enumerate(statevector):\n        if np.abs(element) &gt; tol:\n            # Extract the position revister and base register\n            pos = bin(idx)[2:]\n            base = pos[-2:].zfill(2)\n            # Pad with zeroes if the position is too short\n            if len(pos) &lt; 4:\n                pos = pos.zfill(4)\n            decoded += REV_BASE_MAP[str(base)]\n\n    return decoded\n</code></pre>"},{"location":"encoding_ref/#mps-construction-analysis-and-conversion","title":"MPS construction, analysis, and conversion","text":"<p><pre><code>quantum_genome_encoder.create_mps(statevector, physical_dim, num_nodes, bond_dim)\n</code></pre> </p> <p>Creates an MPS representation of the given state vector.</p>"},{"location":"encoding_ref/#quantum_genome_encoder.create_mps--parameters","title":"Parameters:","text":"<p><code>statevector</code> : <code>np.typing.ArrayLike</code> -      Arbitrary normalised quantum state</p> <p><code>physical_dim</code> : <code>int</code> -      Physical dimension of the given quantum state.</p> <p><code>num_nodes</code> : <code>int</code> -      Number of particles in the given quantum state.</p> <p><code>bond_dim</code> : <code>int</code> -      Number of singlar values kept in the SVD.</p>"},{"location":"encoding_ref/#quantum_genome_encoder.create_mps--returns","title":"Returns:","text":"<p><code>a_matrices</code> : <code>list[tn.Node]</code> -      MPS nodes containing tensors of the MPS representation     of the given quantum state.</p> <p><code>connected_edges</code> : <code>list[tn.Edge]</code> -      List of the connected edges in the MPS reresentation.</p> Source code in <code>quantum_genome_encoder/encoding.py</code> <pre><code>def create_mps(statevector, physical_dim, num_nodes, bond_dim):\n    \"\"\"\n    Creates an MPS representation of the given state vector.\n\n    Parameters:\n    -----------\n    `statevector` : `np.typing.ArrayLike` - \n        Arbitrary normalised quantum state\n\n    `physical_dim` : `int` - \n        Physical dimension of the given quantum state.\n\n    `num_nodes` : `int` - \n        Number of particles in the given quantum state.\n\n    `bond_dim` : `int` - \n        Number of singlar values kept in the SVD.\n\n    Returns:\n    --------\n    `a_matrices` : `list[tn.Node]` - \n        MPS nodes containing tensors of the MPS representation\n        of the given quantum state.\n\n    `connected_edges` : `list[tn.Edge]` - \n        List of the connected edges in the MPS reresentation.\n    \"\"\"\n\n    if bond_dim == 0:\n        bond_dim = 10*10**16\n\n    # First SVD decomposition\n    a_matrices = []\n    ranks = []\n    u_temp, s_temp, vh_temp = np.linalg.svd(\n        statevector.reshape(physical_dim, -1), full_matrices=False\n    )\n    ranks.append(np.linalg.matrix_rank(u_temp[:, :bond_dim]))\n    a_matrices.append(\n        tn.Node(u_temp[:, :bond_dim].reshape(physical_dim, -1), name=\"Node 1\")\n    )\n    statevector = np.diag(s_temp[:bond_dim]) @ vh_temp[:bond_dim, :]\n\n    # Subsequent SVD decompositions\n    for node in range(2, num_nodes):\n        u_temp, s_temp, vh_temp = np.linalg.svd(\n            statevector.reshape(ranks[-1] * physical_dim, -1), full_matrices=False\n        )\n        ranks.append(np.linalg.matrix_rank(u_temp[:, :bond_dim]))\n        a_matrices.append(\n            tn.Node(\n                u_temp[:, :bond_dim].reshape(ranks[-2], physical_dim, ranks[-1]),\n                name=f\"Node {node}\",\n            )\n        )\n        statevector = np.diag(s_temp[:bond_dim]) @ vh_temp[:bond_dim, :]\n\n    # Special treatment for final node\n    final_node = np.diag(s_temp[:bond_dim]) @ vh_temp[:bond_dim, :]\n    final_node /= np.linalg.norm(final_node)\n    a_matrices.append(\n        tn.Node(final_node.reshape(-1, physical_dim), name=f\"Node {num_nodes}\")\n    )\n\n    # Connect edges to build mps\n    connected_edges = []\n    conn = a_matrices[0][1] ^ a_matrices[1][0]\n    connected_edges.append(conn)\n\n    for k in range(1, num_nodes - 1):\n        conn = a_matrices[k][-1] ^ a_matrices[k + 1][0]\n        connected_edges.append(conn)\n\n    return a_matrices, connected_edges\n</code></pre>"},{"location":"mps_ref/","title":"API Reference - MPS Construction","text":"<p>The MPS construction, conversion, and analysis methods (currently also in <code>quantum_genome_encoder.encoding.py</code>) are documented in this section.</p>"},{"location":"mps_ref/#mps-construction-analysis-and-conversion","title":"MPS construction, analysis, and conversion","text":"<p><pre><code>quantum_genome_encoder.create_mps(statevector, physical_dim, num_nodes, bond_dim)\n</code></pre> </p> <p>Creates an MPS representation of the given state vector.</p> <p><pre><code>analyse_required_bond_dim(statevector, num_nodes, physical_dim, make_plots=False, tol=TOL_DEFAULT_ERR, descent_param=DESCENT_PARAM)\n</code></pre> </p> <p>Analyse the required bond dimension of a given MPS to reproduce a state vector within required fidelity.</p> <p><pre><code>convert_mps_to_circuit(statevector, num_nodes, physical_dim, plot_each_iter, tol=TOL_DEFAULT_ERR)\n</code></pre> </p> <p>Converts a given arbitrary normalised quantum state into an MPS representation, and then use that MPS representation to generate a gate-based quantum circuit.</p>"},{"location":"mps_ref/#quantum_genome_encoder.create_mps--parameters","title":"Parameters:","text":"<p><code>statevector</code> : <code>np.typing.ArrayLike</code> -      Arbitrary normalised quantum state</p> <p><code>physical_dim</code> : <code>int</code> -      Physical dimension of the given quantum state.</p> <p><code>num_nodes</code> : <code>int</code> -      Number of particles in the given quantum state.</p> <p><code>bond_dim</code> : <code>int</code> -      Number of singlar values kept in the SVD.</p>"},{"location":"mps_ref/#quantum_genome_encoder.create_mps--returns","title":"Returns:","text":"<p><code>a_matrices</code> : <code>list[tn.Node]</code> -      MPS nodes containing tensors of the MPS representation     of the given quantum state.</p> <p><code>connected_edges</code> : <code>list[tn.Edge]</code> -      List of the connected edges in the MPS reresentation.</p> Source code in <code>quantum_genome_encoder/encoding.py</code> <pre><code>def create_mps(statevector, physical_dim, num_nodes, bond_dim):\n    \"\"\"\n    Creates an MPS representation of the given state vector.\n\n    Parameters:\n    -----------\n    `statevector` : `np.typing.ArrayLike` - \n        Arbitrary normalised quantum state\n\n    `physical_dim` : `int` - \n        Physical dimension of the given quantum state.\n\n    `num_nodes` : `int` - \n        Number of particles in the given quantum state.\n\n    `bond_dim` : `int` - \n        Number of singlar values kept in the SVD.\n\n    Returns:\n    --------\n    `a_matrices` : `list[tn.Node]` - \n        MPS nodes containing tensors of the MPS representation\n        of the given quantum state.\n\n    `connected_edges` : `list[tn.Edge]` - \n        List of the connected edges in the MPS reresentation.\n    \"\"\"\n\n    if bond_dim == 0:\n        bond_dim = 10*10**16\n\n    # First SVD decomposition\n    a_matrices = []\n    ranks = []\n    u_temp, s_temp, vh_temp = np.linalg.svd(\n        statevector.reshape(physical_dim, -1), full_matrices=False\n    )\n    ranks.append(np.linalg.matrix_rank(u_temp[:, :bond_dim]))\n    a_matrices.append(\n        tn.Node(u_temp[:, :bond_dim].reshape(physical_dim, -1), name=\"Node 1\")\n    )\n    statevector = np.diag(s_temp[:bond_dim]) @ vh_temp[:bond_dim, :]\n\n    # Subsequent SVD decompositions\n    for node in range(2, num_nodes):\n        u_temp, s_temp, vh_temp = np.linalg.svd(\n            statevector.reshape(ranks[-1] * physical_dim, -1), full_matrices=False\n        )\n        ranks.append(np.linalg.matrix_rank(u_temp[:, :bond_dim]))\n        a_matrices.append(\n            tn.Node(\n                u_temp[:, :bond_dim].reshape(ranks[-2], physical_dim, ranks[-1]),\n                name=f\"Node {node}\",\n            )\n        )\n        statevector = np.diag(s_temp[:bond_dim]) @ vh_temp[:bond_dim, :]\n\n    # Special treatment for final node\n    final_node = np.diag(s_temp[:bond_dim]) @ vh_temp[:bond_dim, :]\n    final_node /= np.linalg.norm(final_node)\n    a_matrices.append(\n        tn.Node(final_node.reshape(-1, physical_dim), name=f\"Node {num_nodes}\")\n    )\n\n    # Connect edges to build mps\n    connected_edges = []\n    conn = a_matrices[0][1] ^ a_matrices[1][0]\n    connected_edges.append(conn)\n\n    for k in range(1, num_nodes - 1):\n        conn = a_matrices[k][-1] ^ a_matrices[k + 1][0]\n        connected_edges.append(conn)\n\n    return a_matrices, connected_edges\n</code></pre>"},{"location":"mps_ref/#quantum_genome_encoder.analyse_required_bond_dim--parameters","title":"Parameters:","text":"<p><code>statevector</code> : <code>str</code> -      The quantum state to be analysed.</p> <p><code>num_nodes</code> : <code>int</code> -      Number of particles in the generated quantum state.</p> <p><code>physical_dim</code> : <code>int</code> -      Physical dimension of the generated quantum state.</p> <p><code>make_plots</code> : <code>bool</code> -      Plot reconstruction error against bond dimension.</p> <p><code>tol</code> : <code>float</code> -      Default tolerance on reconstruction err, <code>TOL_DEFAULT_ERR</code> by default.</p>"},{"location":"mps_ref/#quantum_genome_encoder.analyse_required_bond_dim--returns","title":"Returns:","text":"<p><code>bond_dim</code> : <code>int</code> -      The required bond dimension for the given tolerance.</p> Source code in <code>quantum_genome_encoder/encoding.py</code> <pre><code>def analyse_required_bond_dim(statevector, num_nodes, physical_dim, make_plots=False, tol=TOL_DEFAULT_ERR):\n    \"\"\"\n    Analyse the required bond dimension of a given MPS to reproduce a state vector\n    within required fidelity.\n\n    Parameters:\n    -----------\n    `statevector` : `str` - \n        The quantum state to be analysed.\n\n    `num_nodes` : `int` - \n        Number of particles in the generated quantum state.\n\n    `physical_dim` : `int` - \n        Physical dimension of the generated quantum state.\n\n    `make_plots` : `bool` - \n        Plot reconstruction error against bond dimension.\n\n    `tol` : `float` - \n        Default tolerance on reconstruction err, `TOL_DEFAULT_ERR` by default.\n\n    Returns:\n    -------\n    `bond_dim` : `int` - \n        The required bond dimension for the given tolerance.\n    \"\"\"\n\n    bond_dim = 1\n    fidelity = 0.\n\n    # Parameter to estimate steps in bond dimension required.\n    # Must be &gt; 0.5 otherwise convergence is not guaranteed.\n    # Smaller -&gt; slower convergence, smaller overestimate.\n    # Larger -&gt; faster convergence, larger overestimate.\n    DESCENT_PARAM = 100.75\n\n    if make_plots:\n        bond_dim_diffs = []\n\n    while fidelity &lt; 1 - tol:\n        _, mps_edges = create_mps(statevector, physical_dim, num_nodes, bond_dim)\n\n        for edge in mps_edges:\n            mps_tensor = tn.contract(edge)\n\n        fidelity = np.linalg.norm(np.dot(statevector.conj(), mps_tensor.tensor.flatten()) ** 2)\n\n        if make_plots:\n            bond_dim_diffs.append((bond_dim, np.round(1 - fidelity, 10)))\n\n        if 1 - fidelity &gt; tol:\n            grad = np.log10( (1 - fidelity) / tol )\n            # Use a descent parameter to ensure we do not wildly\n            # overestimate bond dimension, will require tuning.\n            grad = max(1, int(grad * DESCENT_PARAM))\n            bond_dim += grad\n\n    if make_plots:\n        bond_dim_diffs.pop(0)\n        x, y = zip(*bond_dim_diffs)\n        plt.plot(x, y, \"x\")\n        plt.title(\n            f\"Reconstruction error of state vector for given bond dimension\"\n        )\n        plt.xlabel(\"Bond Dimension\")\n        plt.ylabel(\"Reconstruction Error\")\n        plt.show()\n\n    return bond_dim\n</code></pre>"},{"location":"mps_ref/#quantum_genome_encoder.convert_mps_to_circuit--parameters","title":"Parameters:","text":"<p><code>statevector</code> : <code>np.typing.ArrayLike</code> -      List of number of MPS nodes to be generated for comparison.</p> <p><code>num_nodes</code> : <code>int</code> -      Number of nodes in the MPS.</p> <p><code>physical_dim</code> : <code>int</code> -      Physical dimension of the generated quantum states.</p> <p><code>plot_each_iter</code> : <code>bool</code> -      Show the plot of the circuit and target vector each iteration     in main loop, defaults to <code>False</code>.</p> <p><code>tol</code> : <code>float</code> -      fidelity of MPS representation required to original vector,     defaults to <code>TOL_DEFAULT_ERROR</code></p>"},{"location":"mps_ref/#quantum_genome_encoder.convert_mps_to_circuit--returns","title":"Returns:","text":"<p><code>produced_circuit</code> : <code>qiskit.QuantumCircuit</code> -      Quantum circuit produced from MPS representation.</p> <p><code>gates</code> : <code>int</code> -      Number of gates in the produced quantum circuit.</p> <p><code>entropy</code> : <code>float</code> -      Entropy of given representation.</p> Source code in <code>quantum_genome_encoder/encoding.py</code> <pre><code>def convert_mps_to_circuit(statevector, num_nodes, physical_dim, plot_each_iter, tol=TOL_DEFAULT_ERR):\n    \"\"\"\n    Converts a given arbitrary normalised quantum state into an MPS\n    representation, and then use that MPS representation to generate a\n    gate-based quantum circuit.\n\n    Parameters:\n    ----------\n    `statevector` : `np.typing.ArrayLike` - \n        List of number of MPS nodes to be generated for comparison.\n\n    `num_nodes` : `int` - \n        Number of nodes in the MPS.\n\n    `physical_dim` : `int` - \n        Physical dimension of the generated quantum states.\n\n    `plot_each_iter` : `bool` - \n        Show the plot of the circuit and target vector each iteration\n        in main loop, defaults to `False`.\n\n    `tol` : `float` - \n        fidelity of MPS representation required to original vector,\n        defaults to `TOL_DEFAULT_ERROR`\n\n    Returns:\n    --------\n    `produced_circuit` : `qiskit.QuantumCircuit` - \n        Quantum circuit produced from MPS representation.\n\n    `gates` : `int` - \n        Number of gates in the produced quantum circuit.\n\n    `entropy` : `float` - \n        Entropy of given representation.\n    \"\"\"\n\n    target = copy.copy(statevector)\n    _, mps_edges = create_mps(statevector, physical_dim, num_nodes, 0)\n\n    for edge in mps_edges:\n        mps_tensor = tn.contract(edge)\n\n    _, s_temp, _ = np.linalg.svd(mps_tensor.tensor)\n    s_temp = s_temp[s_temp &gt; 1e-16]\n    entropy = -np.sum(s_temp**2 * np.log(s_temp**2))\n\n    produced_circuit = QuantumCircuit(num_nodes)\n\n    zero_state = np.zeros(statevector.shape[0], dtype=np.complex128)\n    zero_state[0] = 1\n\n    fidelity = 0\n    layer_unitaries = []\n    validation_list = []\n    REQ_SIZE = 15\n    iterations = 0 \n    while fidelity &lt; 1 - tol:\n        # If the last REQ_SIZE sequences decoded have been identical, break.\n        # Idea: break when decoded genome is stable, rather than waiting\n        # on fidelity.\n        # We can tune this parameter for efficiency.\n        if len(validation_list) == REQ_SIZE:\n            break\n\n        iterations += 1\n\n        unitaries = []\n        mps_nodes, mps_edges = create_mps(statevector, physical_dim, num_nodes, 2)\n\n        circuit = QuantumCircuit(num_nodes)\n        v1 = mps_nodes[num_nodes - 1].tensor.reshape(4, -1)\n        v2 = sp.linalg.null_space(v1.conj().T)\n        u_matrix = np.concatenate([v1, v2], axis=1)\n        circuit.unitary(u_matrix, [0, 1])\n        unitaries.append(u_matrix)\n\n        for i in range(1, num_nodes - 1)[::-1]:\n            v1 = mps_nodes[i].tensor.reshape(4, -1)\n            v2 = sp.linalg.null_space(v1.conj().T)\n            u_matrix = np.concatenate([v1, v2], axis=1)\n            circuit.unitary(u_matrix, [(num_nodes - i) - 1, (num_nodes - i)])\n            unitaries.append(u_matrix)\n\n        circuit.unitary(mps_nodes[0].tensor, [num_nodes - 1])\n        unitaries.append(mps_nodes[0].tensor)\n\n        produced_circuit.compose(circuit, range(num_nodes), inplace=True)\n        layer_unitaries.append(Operator(circuit).data)\n\n        statevector = Operator(circuit.inverse()).data @ statevector\n        fidelity = np.abs(np.dot(zero_state.conj(), statevector)) ** 2\n        trial = copy.copy(zero_state)\n        for unitary in layer_unitaries[::-1]:\n            trial @= unitary.T\n\n        decoded_seq = decode_state(trial, num_nodes)\n        if len(validation_list) == 0:\n            validation_list.append(decoded_seq)\n\n        if decoded_seq != validation_list[-1]:\n            validation_list.clear()\n\n        validation_list.append(decoded_seq)\n\n        if plot_each_iter:            \n            plt.figure()\n            plt.bar(range(len(trial)), np.abs(trial)**2, label=r\"$|\\psi_k\\rangle$\", alpha=0.5)\n            plt.bar(range(len(target)), np.abs(target)**2, label=r\"$|\\psi_{\\rm{target}}\\rangle$\", alpha=0.5)\n            plt.ylabel(\"Probability\")\n            plt.legend()\n\n            produced_circuit.draw('mpl')\n            plt.show()\n\n    gates = 0\n    for unitary in layer_unitaries[::-1]:\n        zero_state @= unitary.T\n        gates += 1\n\n    # Qiskit benchmarking checks - not required for functionality\n    # qis_circ = QuantumCircuit(num_nodes)\n    # qis_circ.initialize(target)\n    # qis_trans_circ = transpile(\n    #     qis_circ, basis_gates=[\"x\", \"sx\", \"rz\", \"cx\"], optimization_level=3\n    # )\n\n    return produced_circuit, gates, entropy\n</code></pre>"},{"location":"states_ref/","title":"API Reference - States","text":"<p>Provided with the library are basic generators for regularly used quantum states to demonstrate the capability of the MPS method. We emphasise that the library is designed for use with genomic data.</p> <p><pre><code>generate_w_state(num_qubits)\n</code></pre> </p> <p>Generates an entangled quantum W state for a given number of qubits.</p> <p><pre><code>generate_ghz_state(num_qubits)\n</code></pre> </p> <p>Generates an entangled quantum GHZ (Greenberger-Horne-Zellinger) state for a given number ofqubits.</p> <p><pre><code>generate_gaussian_state(num_qubits)\n</code></pre> </p> <p>Generates a Gaussian state for a given number of qubits.</p> <p><pre><code>generate_random_state(num_qubits)\n</code></pre> </p> <p>Generates a random state for a given number of qubits (currently wrapping around QisKit).</p>"},{"location":"states_ref/#quantum_genome_encoder.generate_w_state--parameters","title":"Parameters:","text":"<p>num_qubits : int     Qubits for required W state.</p>"},{"location":"states_ref/#quantum_genome_encoder.generate_w_state--returns","title":"Returns:","text":"<p>statevector : np.typing.ArrayLike     Corresponding state vector to W state.</p> Source code in <code>quantum_genome_encoder/basic_states.py</code> <pre><code>def generate_w_state(num_qubits):\n    \"\"\"\n    Generates an entangled quantum W state for a given number of\n    qubits.\n\n    Parameters:\n    -----------\n    num_qubits : int\n        Qubits for required W state.\n\n    Returns:\n    --------\n    statevector : np.typing.ArrayLike\n        Corresponding state vector to W state.\n    \"\"\"\n    statevector = np.zeros(2**num_qubits, dtype=np.complex128)\n    bit = 1\n    for i in range(2**num_qubits):\n        if i == bit:\n            statevector[i] = 1 + 0j\n            bit *= 2\n        else:\n            statevector[i] = 0 + 0j\n\n    statevector /= np.sqrt(sum(statevector))\n\n    return statevector\n</code></pre>"},{"location":"states_ref/#quantum_genome_encoder.generate_ghz_state--parameters","title":"Parameters:","text":"<p>num_qubits : int     Qubits for required GHZ state.</p>"},{"location":"states_ref/#quantum_genome_encoder.generate_ghz_state--returns","title":"Returns:","text":"<p>statevector : np.typing.ArrayLike     Corresponding state vector to GHZ state.</p> Source code in <code>quantum_genome_encoder/basic_states.py</code> <pre><code>def generate_ghz_state(num_qubits):\n    \"\"\"\n    Generates an entangled quantum GHZ (Greenberger-Horne-Zellinger)\n    state for a given number ofqubits.\n\n    Parameters:\n    -----------\n    num_qubits : int\n        Qubits for required GHZ state.\n\n    Returns:\n    --------\n    statevector : np.typing.ArrayLike\n        Corresponding state vector to GHZ state.\n    \"\"\"\n    statevector = np.zeros(2**num_qubits, dtype=np.complex128)\n    statevector[0] = 1 / np.sqrt(2)\n    statevector[-1] = 1 / np.sqrt(2)\n\n    return statevector\n</code></pre>"},{"location":"states_ref/#quantum_genome_encoder.generate_gaussian_state--parameters","title":"Parameters:","text":"<p>num_qubits : int     Qubits for required Gaussian state.</p>"},{"location":"states_ref/#quantum_genome_encoder.generate_gaussian_state--returns","title":"Returns:","text":"<p>statevector : np.typing.ArrayLike     Corresponding state vector to Gaussian state.</p> Source code in <code>quantum_genome_encoder/basic_states.py</code> <pre><code>def generate_gaussian_state(num_qubits):\n    \"\"\"\n    Generates a Gaussian state for a given number of qubits.\n\n    Parameters:\n    -----------\n    num_qubits : int\n        Qubits for required Gaussian state.\n\n    Returns:\n    --------\n    statevector : np.typing.ArrayLike\n        Corresponding state vector to Gaussian state.\n    \"\"\"\n    mu, sigma = (2**num_qubits) / 2, (2**num_qubits) / 4\n\n    gaus = np.array(\n        [np.sqrt(norm(mu, sigma).pdf(i)) for i in range(2**num_qubits)]\n    )\n    statevector = gaus / np.linalg.norm(gaus)\n\n    return statevector\n</code></pre>"},{"location":"states_ref/#quantum_genome_encoder.generate_random_state--parameters","title":"Parameters:","text":"<p>num_qubits : int     Qubits for required Gaussian state.</p>"},{"location":"states_ref/#quantum_genome_encoder.generate_random_state--returns","title":"Returns:","text":"<p>statevector : np.typing.ArrayLike     Corresponding random state vector.</p> Source code in <code>quantum_genome_encoder/basic_states.py</code> <pre><code>def generate_random_state(num_qubits):\n    \"\"\"\n    Generates a random state for a given number of qubits (currently wrapping\n    around QisKit).\n\n    Parameters:\n    -----------\n    num_qubits : int\n        Qubits for required Gaussian state.\n\n    Returns:\n    --------\n    statevector : np.typing.ArrayLike\n        Corresponding random state vector.\n    \"\"\"\n    return random_statevector(2**num_qubits).data\n</code></pre>"}]}